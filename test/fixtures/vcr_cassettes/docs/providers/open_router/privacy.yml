---
http_interactions:
- request:
    method: post
    uri: https://openrouter.ai/api/v1/chat/completions
    body:
      encoding: UTF-8
      string: '{"messages":[{"role":"user","content":"Explain the SOLID principles"}],"model":"openrouter/auto","provider":{"data_collection":"deny","zdr":true}}'
    headers:
      Content-Type:
      - application/json
      Authorization:
      - Bearer ACCESS_TOKEN
      Http-Referer:
      - https://example.com
      X-Title:
      - Dummy
      Accept-Encoding:
      - gzip;q=1.0,deflate;q=0.6,identity;q=0.3
      Accept:
      - "*/*"
      User-Agent:
      - Ruby
  response:
    status:
      code: 200
      message: OK
    headers:
      Date:
      - Sat, 25 Oct 2025 04:35:36 GMT
      Content-Type:
      - application/json
      Transfer-Encoding:
      - chunked
      Connection:
      - keep-alive
      Access-Control-Allow-Origin:
      - "*"
      Vary:
      - Accept-Encoding
      Permissions-Policy:
      - payment=(self "https://checkout.stripe.com" "https://connect-js.stripe.com"
        "https://js.stripe.com" "https://*.js.stripe.com" "https://hooks.stripe.com")
      Referrer-Policy:
      - no-referrer, strict-origin-when-cross-origin
      X-Content-Type-Options:
      - nosniff
      Server:
      - cloudflare
      Cf-Ray:
      - 993f0207bdeace48-SJC
    body:
      encoding: ASCII-8BIT
      string: "\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n
        \        \n\n         \n\n         \n\n         \n\n         \n{\"id\":\"gen-1761366934-ZcxpSINGnRBEfdWUnBy5\",\"provider\":\"DeepInfra\",\"model\":\"mistralai/mistral-nemo\",\"object\":\"chat.completion\",\"created\":1761366936,\"choices\":[{\"logprobs\":null,\"finish_reason\":\"stop\",\"native_finish_reason\":\"stop\",\"index\":0,\"message\":{\"role\":\"assistant\",\"content\":\"The
        SOLID principles are five object-oriented design principles intended to make
        software designs more understandable, flexible, and maintainable. They are
        fundamental principles that help developers create more stable and scalable
        code. SOLID is an acronym that stands for:\\n\\n1. **Single Responsibility
        Principle (SRP)**\\n   - A class should have only one reason to change.\\n
        \  - This means that a class should only have one job or responsibility. If
        a class has more than one responsibility, it becomes coupled, and changes
        to one responsibility may impair the others. This makes the system more rigid
        and harder to maintain.\\n\\n2. **Open-Closed Principle (OCP)**\\n   - Software
        entities (classes, modules, functions, etc.) should be open for extension
        but closed for modification.\\n   - This means that you should be able to
        extend a class's behavior without modifying it. This can be achieved through
        techniques like inheritance, composition, or extension methods. The main benefit
        of this principle is that it allows you to add new functionality without breaking
        existing code.\\n\\n3. **Liskov Substitution Principle (LSP)**\\n   - Subtypes
        must be substitutable for their base types.\\n   - This means that if a program
        is using a base class, it should be able to use any of its subclasses without
        the program knowing. In other words, subclasses must behave in the same way
        as their base classes. This ensures that your code is more predictable and
        less prone to errors.\\n\\n4. **Interface Segregation Principle (ISP)**\\n
        \  - Make fine-grained interfaces that are client-specific.\\n   - This means
        that it's better to have many smaller, more specific interfaces than to have
        one large, all-encompassing interface. This is because clients should only
        see methods they're interested in, reducing dependencies and coupling.\\n\\n5.
        **Dependency Inversion Principle (DIP)**\\n   - Depend upon abstractions,
        [don't] depend upon concretions.\\n   - This means that high-level modules
        should not depend on low-level modules. Both should depend on abstractions.
        This can be achieved through techniques like dependency injection. The main
        benefit of this principle is that it makes your code more modular, testable,
        and easier to maintain.\\n\\nBy following these principles, you can create
        more flexible, maintainable, and extensible code. They are a key part of writing
        clean, efficient, and scalable software.\",\"refusal\":null,\"reasoning\":null}}],\"usage\":{\"prompt_tokens\":10,\"completion_tokens\":478,\"total_tokens\":488,\"prompt_tokens_details\":null}}"
  recorded_at: Sat, 25 Oct 2025 04:36:00 GMT
recorded_with: VCR 6.3.1
